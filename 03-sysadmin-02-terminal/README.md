# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

`cd` — встроена команда в оболочку  
```bash
$ type cd
cd is a shell builtin
```
2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

Альтернатива — `grep <some_string> <some_file> -c`
```bash
$ cat text_file
123
123
222
$ grep 123 text_file -c
2
```
3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Процесс с PID1 `systemd`
```bash
$ ps -p 1 -o comm=
systemd
$ pstree -a -p  | head -n 1
systemd,1
$ sudo ls -l /proc/1/exe
lrwxrwxrwx  1 root root 0 Jun 17 14:18 exe -> /usr/lib/systemd/systemd
```
4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
```bash
$ ls -l file1 2>/dev/pts/1 #перенаправили ls в tty1
tty
/dev/pts/1
$ ls: cannot access 'file1': No such file or directory #tty1 вывел ошибку
```
5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```bash
$ ls -l file1 2>error.out #вариант 1
$ cat error.out
ls: cannot access 'file1': No such file or directory
$ echo hello >hello.file #вариант 2
$ cat hello.file
hello
$ cat hello.file > hi.file #вариант 3
$ cat hi.file
hello
```
6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

`Да можно —` отправил с терминального PTY `Hello TTY1`, сообщение не увидел, т.к. был запущен TTY4, переключился на TTY1 (Cnt+Shiht+1), сообщение увидел. Отправил из TTY1 сообщение `Hi PTY0`, сообщение увидел на терминале PTY1.
[TTY-PTY]() 


7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

`bash 5>&1` запустит экземпляр bash с дополнительным фаловым дескриптором "5" и перенаправит его на ф/д 1 (stdout).
```bash
vagrant@vagrant:~$ ll /proc/$$/fd/5
lrwx------ 1 vagrant vagrant 64 Jun 19 13:06 /proc/5764/fd/5 -> /dev/pts/0
```
`echo netology > /proc/$$/fd/5` выведет в терминал слово "netology". Это произойдёт потому что echo отправляет netology в файловый дескриптор с номером 5 текущего шела (подсистема /proc содержит информацию о запущенных процессах по их PID, $$ - подставит PID текущего шелла, в "папке" fd можно посмотреть на какие файлы ссылаются дескрипторы по номерам)
```bash
vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
netology
```

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
```bash
vagrant@vagrant:~$ ll /root 6>&2 2>&1 1>&6 | grep "Permission denied" -c
1
```
6>&2 — новый дескриптов 6 направили в stderr, 2>&1 — stderr направили в stdout, 1>&6 — stdout направили в новый дескриптор.

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

`cat /proc/$$/environ` — выведет переменные окружения. Аналог env и printenv.

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

 `/proc/<PID>/cmdline` — полный путь к исполняемому файлу процесса PID
`/proc/<PID>/exe`— символическая ссылка (симилинк), на полный путь к исполняемому файлу процесса PID.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
```bash
vagrant@vagrant:~$ cat /proc/cpuinfo  | grep -o 'sse[0-9_]*' | sort -h | uniq
sse
sse2
sse3
sse4_1
sse4_2
```
12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
	```
		Почитайте, почему так происходит, и как изменить поведение.
Из ответа на Stackowerflow. По умолчанию, когда вы запускаете команду на удаленном компьютере с помощью ssh, TTY не выделяется для удаленного сеанса. Это позволяет передавать двоичные данные и т. Д. Без необходимости работать с причудами TTY. Это среда, предусмотренная для команды, выполняемой на computerone. Однако, когда вы запускаете ssh без удаленной команды, он выделяет TTY, потому что вы, скорее всего, будете запускать сеанс оболочки.
Изменить поведение можно добавив флаг -t при вызове ssh.


13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

Например чтобы процесс запущенный в SSH сессии продолжал работать можно его перенести в screen
при нескольких запущенных сессиях выведет их список с идентификаторами:
```bash
ping ya.ru -n 1000 -S screen #отправить процес ping в screen
screen -r #отобразить текущие сессии screen
screen -r <pid.tty.host> #подключеиться к одной из screen сессий
```
Но что, если вы забыли запустить команды в screen / tmux в первую очередь?
Не беспокойся. Вот где Рептир приходит на помощь. Reptyr помогает вам перемещать запущенные процессы между pty.

`Repryr` использовать не безопасно, это посути эксплоит PID.
```bash
apt install reptyr
vagrant@vagrant:~$ tty
/dev/pts/0
ping ya.ru -n 1000 #Запустили Ping в PTY0
```
```bash
vagrant@vagrant:~$ tty
/dev/pts/2
vagrant@vagrant:~$ ps -a
    PID TTY          TIME CMD
   5194 tty2     00:00:00 bash
   5270 tty3     00:00:00 bash
   5376 tty4     00:00:00 bash
   6413 tty1     00:00:00 bash
   6538 pts/0    00:00:00 ping
   6606 pts/1    00:00:00 ps

vagrant@vagrant:~$ sudo su
root@vagrant:/home/vagrant# echo 0 > /proc/sys/kernel/yama/ptrace_scope
vagrant@vagrant:~$ sudo reptyr 6538 #Подключились к PID Ping PTY0
64 bytes from 87.250.250.242: icmp_seq=4 ttl=53 time=52.6 ms
64 bytes from 87.250.250.242: icmp_seq=5 ttl=53 time=47.8 ms
64 bytes from 87.250.250.242: icmp_seq=6 ttl=53 time=54.2 ms
64 bytes from 87.250.250.242: icmp_seq=7 ttl=53 time=50.7 ms
64 bytes from 87.250.250.242: icmp_seq=8 ttl=53 time=48.1 ms
64 bytes from 87.250.250.242: icmp_seq=9 ttl=53 time=53.5 ms

```
14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

`tee` умеет писать в файл, tee берёт stdin и отправляет это в stdout или файл, а у echo есть только аргументы, которые она умеет отправлять только в stdout.
В отличие от неё, вывод echo хоть и можно перенаправить, но само перенаправление делает родительский shell, и если у него нет рут-прав, то в "привелегированные" файлы писать не получится.
Поэтому используется комбинация: `echo string | sudo tee /root/new_file`.

---
